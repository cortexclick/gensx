---
title: Contexts and Providers
description: Learn how to use contexts and providers in GenSX to share data across components.
sidebar:
  order: 3
---

Contexts and providers are a powerful tool in GenSX for sharing data and managing configuration across components without explicitly passing props through every level of your component tree. They work similarly to [React's Context API](https://react.dev/reference/react/useContext) and are adapted to work with GenSX workflows.

## What are contexts and providers?

Contexts and providers are two closely related concepts that work together to share data and manage dependencies across components.

**Contexts** provide a way to share data (like state, configuration, or dependencies) across components without manually passing props down the component tree.

Contexts are particularly useful for:

- Sharing configuration across multiple components
- Providing dependencies to deeply nested components without prop drilling
- Managing state that needs to be accessed by multiple components

**Providers** are components that supply data or services to a context. Any component within a provider's subtree can access the context.

Providers are ideal for:

- Centralizing configuration management (e.g., API keys, client instances).
- Sharing data or services across components.
- Scoping state or dependencies to specific parts of your workflow.

The remainder of this document will show you how to create and use contexts and providers in GenSX.

## Creating and using contexts

### Step 1: Create a context

To create a context, start by defining its interface and then use `gsx.createContext<T>()` to initialize it along with a default value. For example, here's how to create a `User` context:

```tsx
import { gsx } from "gensx";

// Define the interface
interface User {
  name: string;
}

// Create a context with a default value
const UserContext = gsx.createContext<User>({
  name: "",
});
```

### Step 2: Use the context in a component

To use the context, call the `gsx.useContext(context)` hook inside of a component. Here a `Greeting` component is created that uses the `UserContext` to get the user's name:

```tsx
// Use the context in a component
const Greeting = gsx.Component<Record<never, never>, GreetingOutput>(
  "Greeting",
  () => {
    const user = gsx.useContext(UserContext);
    return `Hello, ${user.name}!`;
  },
);
```

### Step 3: Provide the context value

To make the context value available to your components, you need to wrap your component in a `Provider` component and pass in a value via the `value` prop:

```tsx
const result = await gsx.execute(
  <UserContext.Provider value={{ name: "John" }}>
    <Greeting />
  </UserContext.Provider>,
);
```

## Using providers for configuration and dependencies

Providers are a specialized use of contexts that focus on managing configuration and dependencies for your workflow. While you could use raw contexts for this purpose, providers offer a more focused API specifically for configuration management.

The main provider available today is the `OpenAIProvider`, which manages your OpenAI API key and client:

```tsx
const result = await gsx.execute(
  <OpenAIProvider apiKey={process.env.OPENAI_API_KEY}>
    <ChatCompletion
      model="gpt-4"
      messages={[{ role: "user", content: "Hello!" }]}
    />
  </OpenAIProvider>,
);
```

Providers offer several benefits:

- **Centralized Configuration Management** - providers manage settings like API keys and feature flags keeping configuration separate from business logic
- **Data Sharing** - providers give you an easy way to share data between components without prop drilling to simplify your code
- **Reusability** - providers and their associated components can easily be reused in different parts of your application
- **Scoped State Management** - providers can be used to manage state for parts of your workflow or the entire thing

## Creating a Custom Provider

If you want to use a provider that isn't available out of the box, you can easily create your own. The example below shows how to create a provider for the [Firecrawl](https://www.firecrawl.dev/) API.

### Step 1: Create a context

Start by importing `gsx` and the package you want to use:

```tsx
import { gsx } from "gensx";
import FirecrawlApp, { FirecrawlAppConfig } from "@mendable/firecrawl-js";
```

Then, create the context:

```tsx
// Create a context
export const FirecrawlContext = gsx.createContext<{
  client?: FirecrawlApp;
}>({});
```

The context contains the `client` that you'll use to interact with the Firecrawl API.

### Step 2 Create the provider

Next, wrap your context in a provider component:

```tsx
// Create the provider
export const FirecrawlProvider = gsx.Component<FirecrawlAppConfig, never>(
  "FirecrawlProvider",
  (args: FirecrawlAppConfig) => {
    const client = new FirecrawlApp({
      apiKey: args.apiKey,
    });
    return <FirecrawlContext.Provider value={{ client }} />;
  },
);
```

The provider will take in the `apiKey` as a prop and use it to initialize the Firecrawl client.

### Step 3: Use the provider in a component

Finally, you can build components that consume the context provided by the provider:

```tsx
export const ScrapePage = gsx.Component<ScrapePageProps, string>(
  "ScrapePage",
  async ({ url }) => {
    const context = gsx.useContext(FirecrawlContext);

    if (!context.client) {
      throw new Error(
        "Firecrawl client not found. Please wrap your component with FirecrawlProvider.",
      );
    }
    const result = await context.client.scrapeUrl(url, {
      formats: ["markdown"],
      timeout: 30000,
    });

    if (!result.success || !result.markdown) {
      throw new Error(`Failed to scrape url: ${url}`);
    }

    return result.markdown;
  },
);
```

### Step 4: Use the provider in your workflow

Now when you use the `ScrapePage` component in your workflow, you'll wrap it in the `FirecrawlProvider` and pass in the `apiKey`:

```tsx
const markdown = await gsx.execute(
  <FirecrawlProvider apiKey={process.env.FIRECRAWL_API_KEY}>
    <ScrapePage url="https://gensx.dev/overview/" />
  </FirecrawlProvider>,
);
```

## Best Practices

While contexts and providers are powerful tools, they do make your components less reusable since they create implicit dependencies. Here are some guidelines for using them effectively:

1. Use providers for managing configuration and external service dependencies
2. Use raw contexts sparingly and only when prop drilling would make your code significantly more complex
3. Keep context values simple and focused on a single concern
4. Document the contexts and providers that components depend on

## Additional Resources

You can find example code demonstrating these concepts on GitHub:

- [Context examples](https://github.com/cortexclick/gensx/tree/main/examples/contexts)
- [Provider examples](https://github.com/cortexclick/gensx/tree/main/examples/providers)
